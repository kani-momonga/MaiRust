# MaiRust Design Notes - Open Questions & Proposed Decisions
Apache-2.0 / PostgreSQL-First

本ドキュメントは、MaiRust の初期設計で挙がった不明点・要検討事項に対する
**暫定方針・設計案**をまとめたものです。  
最終決定ではなく、「設計レビューのたたき台」として利用します。

---

## 0. 前提

- **MaiRust 本体ライセンス: Apache-2.0**
- **デフォルトDB: PostgreSQL**
  - 他DBは「プラガブルな Storage Backend」として追加対応

---

## 1. Architecture

### 1.1 ストレージ設計の詳細

#### 1.1.1 PostgreSQL vs SQLite の選択基準

**方針:**
- **PostgreSQL を推奨＆デフォルト**
- SQLite は以下用途に限定:
  - 開発・検証環境
  - 単一ノード・小規模（想定：〜数ユーザー、〜数万通/日）運用
  - 組み込み用途（コンテナ1個で完結した簡易構成）

**推奨指針（暫定）:**

- SQLite を推奨するケース
  - 単一ノード
  - 同時接続ユーザ < 20
  - メール通数 < 10万通/日
  - 高可用性・レプリケーション不要

- PostgreSQL を推奨/必須とするケース
  - 複数ノード構成
  - 高可用性 (HA) やレプリケーションを必要とする
  - 大量データ（数百万〜数千万通以上）を前提とする
  - フルテキスト検索・プラグインメタ情報など拡張を多用する

実装面では、DBは `StorageBackend` トレイトで抽象化し、
`postgres`, `sqlite` を公式サポート、将来 `mysql` 等も拡張可能とします。

#### 1.1.2 S3互換ストレージの要件・テスト方針

**最初の要件:**

- S3 API v4 署名に対応
- `PUT`, `GET`, `HEAD`, `DELETE`, マルチパートアップロード
- バケット単位で暗号化（サーバサイド or クライアントサイド）を選択可能
- メール本体は「不変オブジェクト」として保存（更新は新オブジェクト）

**テスト対象候補:**

- AWS S3
- MinIO
- Wasabi（可能であれば）

**テスト方針:**

- 「S3ドライバ」用の共通テストスイートを用意
- CI 等で MinIO を立ち上げて互換性テスト
- 本番環境では、AWS S3 をリファレンス実装として扱う

#### 1.1.3 フルテキスト検索の位置づけ

**方針:**

- **フルテキスト検索は「オプション機能」**
- コア機能は検索エンジン無しでも動作
- 検索エンジンありの場合:
  - メール本文・ヘッダの全文検索が高速化
  - 複雑なフィルタ・AI連携の絞り込みが可能に

**インストール構成への影響:**

- 「最小構成」: DB + ローカルFS のみ（検索はDBのLIKEベース）
- 「標準構成」: DB + FS + Meilisearch
- 「大規模構成」: DB + S3 + Elasticsearch or OpenSearch

README / インストーラで、「検索エンジンなし構成」と「検索エンジンあり構成」を明示的に分けて紹介します。

---

### 1.2 Hook Manager の詳細

#### 1.2.1 pre_receive フックのタイムアウト

**方針:**

- デフォルト: 2 秒
- 最大: 5 秒（グローバル上限）
- 設定単位: フックごとに `timeout_ms` を設定可能（上限5秒）

タイムアウト時の挙動はフックごとにポリシーを持つ:

- `on_timeout: allow | reject | tempfail`
  - デフォルト: `tempfail`（4xx返却）  
  - ただし、明示的に `allow` を設定できる（外部AI遅延で受信をブロックしたくない場合）

#### 1.2.2 同一フックへの複数プラグイン登録時の順序

**方針:**

- 各フックには `priority` (整数, 低いほど先) を設定可能
- 実行順:
  1. `priority` 昇順
  2. 同じpriority内では `name` の辞書順

**結果の合成ルール（暫定）:**

- `reject`/`tempfail` を返したプラグインがあれば、その時点でチェーンを中断
- `tag`/`annotate` 型の結果はマージ（重複タグは除外）
- 最終的な「配送アクション」は「もっとも強い結果」を採用
  - `reject > tempfail > deliver`

#### 1.2.3 SMTPレスポンスコード設計

**方針:**

- プラグインは `action` と併せて `code` と `permanent` を返せる
  - `permanent = true` → 5xx
  - `permanent = false` → 4xx
- `code` 未指定の場合:
  - `reject` → `550 5.7.1`
  - `tempfail` → `451 4.7.1`

メールポリシー系（ブラックリスト等）は基本 5xx、  
外部サービスエラー・タイムアウトは 4xx を推奨。

---

### 1.3 API 設計

#### 1.3.1 REST vs GraphQL

**方針:**

- **REST をプライマリAPIとする**
- GraphQL は「拡張 / 高度なクライアント向け」として後から追加

理由:

- 管理系・Webhook・プラグイン連携などは REST の方が扱いやすい
- メールクライアント向けには GraphQL の利点もあるが、  
  初期フェーズでは開発・運用コストを REST に集中させたい

GraphQL 導入時は `/api/graphql` に単一エンドポイントを提供し、  
内部的には REST 層をラップする形を想定。

#### 1.3.2 API バージョニング

**方針:**

- URL プレフィックス方式: `/api/v1/...`
- メジャーバージョンアップ時に `/api/v2/...` を追加
- 旧バージョンは一定期間（例: 12〜24ヶ月）サポート

ヘッダベース（`Accept: application/vnd.mairust.v1+json`）は将来対応可能としつつ、  
初期は URL ベースで分かりやすさを優先します。

---

## 2. Plugin Architecture

### 2.1 プラグイン実行環境

#### 2.1.1 サンドボックス実装

**段階的アプローチ:**

- Phase 1:
  - 外部HTTP / STDIN (ローカルプロセス) ベース
  - OSユーザー分離 + ulimit/cgroup による制限
  - コンテナ/WASMは使わない（運用を軽くする）

- Phase 3 以降（オプション機能として検討）:
  - containerd / Docker integration
  - WASM ランタイム（Wasmtime等）による軽量プラグイン

#### 2.1.2 リソース制限

**設定例（plugin.toml）:**

```toml
[limits]
cpu_ms = 500       # 0.5秒分のCPU時間
memory_mb = 256
wall_time_ms = 2000
network = "outbound-limited"  # none | local-only | outbound-limited | unlimited
````

実装:

* Linux では cgroup / ulimit を利用（サポート環境で有効）
* 非対応環境ではベストエフォート（警告出力）

#### 2.1.3 対応プロトコル

**初期対応:**

* HTTP(S)
* STDIN/STDOUT（ローカルスクリプト）

**中期対応（オプション）:**

* gRPC
* UNIX domain socket (`unix:///path/to/socket`)

HTTP と UNIX domain socket はよく似た実装で扱えるので、
内部的には「トランスポート抽象化」で対応予定。

---

### 2.2 権限システム

#### 2.2.1 `read_body = "preview"` の定義

**方針:**

* `preview` = 「テキスト本文の先頭 4KB」

  * 文字数ではなくバイト数（UTF-8 4KB）
  * マルチパートの場合、text/plain 部分の先頭 4KB を対象

理由:

* プラグインに必要最低限のコンテキストを渡しつつ、
* プライバシーと帯域の両方を保護できる妥当な量

#### 2.2.2 書き込み可能な属性

**権限フラグ例:**

* `write_tags` … タグの追加/削除
* `write_flags` … 既読/未読、スター、重要フラグ等
* `move_message` … フォルダ移動
* `write_metadata` … カスタムメタデータ（`plugin:<id>:key` 名前空間限定）

将来拡張として、返信草稿作成なども権限化の対象になり得る。

#### 2.2.3 権限昇格ワークフロー

**方針:**

* プラグインは `plugin.toml` で要求スコープを宣言
* インストール時に Admin UI で「権限レビュー」画面を表示
* 権限変更（アップグレード含む）の場合は再度確認が必要

例:

* 初回: `read_headers` のみ → 自動承認
* アップデートで `read_body = full` を要求 → Admin 承認必須 & ログ記録

---

### 2.3 認証・セキュリティ

#### 2.3.1 X-MaiRust-Signature

**方針:**

* アルゴリズム: `HMAC-SHA256`
* 形式: `X-MaiRust-Signature: sha256=<hex>`
* メッセージ: リクエストボディ + 一部ヘッダ（日時等）を結合

**キー管理:**

* プラグインごとに「共有シークレット」を発行
* シークレットは DB で暗号化保存（例: envelope encryption）
* シークレットは API から再発行可能
* ローテーション時:

  * 現行キー + 新キー の2本を一定期間受け入れる「グレース期間」を用意

#### 2.3.2 プラグイントークン

MaiRust → プラグイン、プラグイン → MaiRust の両方向で利用。

* 形式: 短命の JWT or ランダムトークン
* スコープ:

  * `plugin:<id>:callback`
  * `plugin:<id>:metrics` など
* ローテーション:

  * 管理UI/APIから再発行
  * 一定期間での自動ローテーション（将来）

---

### 2.4 UI Plugin

#### 2.4.1 技術スタック

**方針:**

* ホスト側: React (Next.js)
* プラグイン側: **自由（Reactに限定しない）**

UIプラグインは、基本的に「iframe で埋め込むマイクロフロントエンド」として扱う。

#### 2.4.2 サンドボックス方式

* iframe + `sandbox` 属性 でDOM分離
* postMessage API で MaiRust とやり取り
* 認証は、iframe読み込み時に短命のトークンをクエリ or ヘッダで付与

こうすることで、ブラウザ側のセキュリティモデルを活用しつつ、
プラグイン開発者に技術スタックの自由度を与える。

---

## 3. Marketplace

### 3.1 ビジネスモデル

**方針（暫定・OSS版では必須ではない記述）:**

* コアは Apache-2.0 OSS として、Marketplace は別サービスとして位置付け可能
* 収益モデル候補:

  * 有料プラグイン販売時の手数料（例: 10〜30%）
  * エンタープライズ向け「プライベートMarketplace機能」のサブスクリプション
* 初期OSSフェーズでは「無料プラグイン + 寄付/スポンサー」を前提とし、
  手数料モデルは将来の商用版検討事項とする

**開発者審査:**

* 自己申告メタデータ + 自動静的解析（依存関係チェック）
* 高権限プラグイン（full body, write_metadata 等）は別途レビュー枠
* OSSプラグインはソース公開を推奨

### 3.2 技術的詳細

#### 3.2.1 署名と鍵管理

**基本モデル:**

* 開発者署名: プラグインパッケージに開発者鍵で署名 (optional)
* Marketplace署名: Marketplace が「検証済みパッケージ」として再署名 (必須)

信頼チェーン:

* MaiRust インスタンスは Marketplace の公開鍵を信頼
* 開発者署名はメタ情報として表示（信頼向上の材料）

#### 3.2.2 オフライン環境

* プラグインは `.mairust-plugin` のようなアーカイブ形式でエクスポート
* Air-gapped 環境では:

  * 外部ネットワークでプラグイン取得
  * オフラインインスタンスへ手動アップロードしてインポート
* ライセンス・署名検証はオフラインでも可能なように設計

#### 3.2.3 依存関係管理

**初期方針:**

* Phase 1〜2 では「プラグイン間依存は非推奨 or 非対応」
* どうしても必要な場合は「ライブラリ側に依存」「外部サービスに依存」を推奨

将来:

* plugin.toml に `depends = ["other.plugin.id>=1.2.0"]` のような記述を導入
* 解決・競合の処理が複雑になるため、実装タイミングは後ろ倒し

### 3.3 プライバシー

**Marketplace 接続時に送信する情報（案）:**

* 必須:

  * MaiRust バージョン
  * OS種別 (Linux/ARM64など)
* オプション（デフォルトOFF、明示的オプトインで送信）:

  * 有効なプラグインIDの一覧
  * 概算規模（ユーザー数のレンジ: 1–10 / 10–100 / 100+ 等）

**絶対に送らない情報:**

* ドメイン名
* メールアドレス
* メッセージ内容/件名/ヘッダ

---

## 4. Roadmap

### 4.1 優先順位の根拠

#### 4.1.1 Phase 1 の AI Worker

**候補:**

* A. スパム検出
* B. 要約

**方針:**

* **Phase 1: スパム検出を優先**

  * メール基盤としての実用性に直結
  * チューニングは難しいものの、既存のスパム判定エンジンとの連携も可能

* 要約は「価値は高いがコアインフラというより利便性」なので、

  * Phase 1ではシンプルな「サンプルプラグイン」として実装
  * 本格的な要約/分類は Phase 2 以降の AI プラグインとして強化

#### 4.1.2 IMAP/POP のタイミング

**課題認識:**

* IMAP/POP なしだと「既存メールクライアントから使えない」
* しかし、実装コストが高い

**案:**

* Phase 2 の後半か 2.5 フェーズとして **IMAP（読み取り中心）を前倒し**

  * 最初は「read-only IMAP + Web UI + API」で実用性を確保
  * その後にフラグ更新等の書き込みサポートを拡張

---

### 4.2 未定技術の方向性

#### 4.2.1 Kubernetes Operator

**対象:**

* MaiRust Core
* API Server
* Plugin Worker
* 検索エンジン（Meilisearch / Elasticsearch）
* DB / S3 はマネージドサービス前提が多い

Helm Chart との関係:

* Helm: 単なるデプロイテンプレート
* Operator: バージョン管理・ローリングアップデート・設定同期・バックアップ連携等を担当

#### 4.2.2 SaaS Control Plane

**想定機能:**

* テナント管理（ドメイン・ユーザー数・プラン）
* 構成の一元管理（メールルーティング・ポリシー）
* メトリクスダッシュボード
* 課金連携（Stripe等）
* プラグインMarketplaceとの統合（テナントごとのプラグインインストール管理）

---

## 5. Competition

### 5.1 差別化ポイントの深掘り

#### 5.1.1 「API-first」の具体性

**MaiRust での意味:**

* すべての管理操作が API 経由で可能（UI は「API クライアント」に過ぎない）
* Hooks / Plugins / Marketplace / Monitoring も API で完全管理
* API スキーマ・バージョン管理を明示的に設計

Stalwart も REST API を持つが、MaiRust は

* 「プラグイン・マーケット・AI連携」まで含めて API で統一する点、
* 「API と Web UI の分離」を原則にする点

でより強く「API-first」を前面に出す。

#### 5.1.2 「AI Workflows」の具体例

例シナリオ:

1. `support@company.com` 宛てメール:

   * 受信 → `post_receive` Hook → AI プラグイン
   * カテゴリ分類（バグ報告 / 問い合わせ / 請求 etc.）
   * チケットシステムに自動登録、Slack通知

2. 営業系メール:

   * 「HOT度スコア」をAIで算出
   * 高スコアのものだけ専用フォルダ/ラベルに振り分け
   * 日次で「AI要約レポート」を生成して担当に送信

3. セキュリティ・DLP:

   * 機密情報っぽい文言/添付（マイナンバー・クレカ等）を検知
   * 社外送信前に `pre_send` Hook でブロック or 承認フローへ

---

### 5.2 互換性・移行

#### 5.2.1 既存サーバからの移行

**方針:**

* `mairust import maildir /path/to/maildir`
* `mairust import mbox /path/to/mbox`

のような CLI を用意し、既存メールボックスから段階的移行を可能にする。

#### 5.2.2 Postfix/Dovecot との併用

* MaiRust を最初は **MDA/ストレージ層としてのみ利用**できる構成を想定

  * Postfix → (LMTP or pipe) → MaiRust
  * MaiRust → IMAPサーバ（Dovecot等）へのブリッジ
* 段階的に:

  * 受信のみ MaiRust
  * 送信も MaiRust
  * 最終的に Postfix/Dovecot を段階的にリプレイス

---

## 6. 全体の未定義事項への方針

### 6.1 ライセンス

* **MaiRust 本体: Apache-2.0**

  * 商用利用しやすく、特許条項もカバー
  * プラグインは MIT / Apache / Proprietary など柔軟に選択可能

### 6.2 対応OS

優先度:

1. Linux (x86_64, aarch64) — **公式サポート**
2. その他（BSD, macOS） — 開発/検証向けとして「ベストエフォート」
3. Windows — 開発用のみ（本番運用は非推奨）

### 6.3 最小要件（暫定）

* 開発/小規模:

  * 2 vCPU
  * 2 GB RAM
  * 20 GB disk
* 中規模:

  * 4 vCPU+
  * 8 GB RAM+
  * DB・オブジェクトストレージは別途

正式な sizing ガイドは後続で作成。

### 6.4 国際化 (i18n)

* 初期は英語のみ
* 文言は i18n フレンドリーな仕組みで管理（JSON/YAML等）
* 日本語・英語を優先対応、コミュニティ翻訳も受け入れ

### 6.5 監視

* Prometheus メトリクスを標準提供

  * SMTP/HTTPリクエスト数、レイテンシ、キュー長 etc.
* OpenTelemetry でトレース/ログをエクスポート可能に
* Admin UI に簡易ダッシュボード

### 6.6 バックアップ

* 推奨手順:

  * DB (PostgreSQL) のスナップショット / ダンプ
  * メールボディ（FS/S3）のスナップショット
  * 設定（YAML, plugin.toml, Hooks設定）のエクスポート

将来的に `mairust backup` / `mairust restore` コマンドを提供。

### 6.7 高可用性

* 第一段階: Active-Passive

  * 外部DB + 共有ストレージ（S3等）
  * LB/フェイルオーバーで切替

* 次段階: Active-Active

  * 複数ノードでキューとストレージを共有
  * IMAP 等の状態管理が課題となるため、フェーズを分けて実装

---
