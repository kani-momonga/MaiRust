# MaiRust 設計ノート v3  
最終確認事項への回答・調整案

---

## 1. 設計の矛盾・要調整

### 1.1 Hook タイムアウトと Circuit Breaker

#### 現状
- pre_receive timeout: 最大 5 秒
- Circuit Breaker: 連続 10 回失敗 or 5 分間失敗率 > 80%

#### 調整方針

**A. pre_receive 専用の厳しい Circuit Breaker を導入**

- 全体ポリシーとは別に、`pre_receive` 用の閾値を定義：
  - 連続 **3 回** タイムアウト or エラー → 即 Circuit Open
  - Circuit Open 中は「そのプラグインをスキップして allow」とする（※設定で reject も選べるがデフォルトは allow）
- 失敗率判定は短い窓で見る：
  - 直近 1 分の失敗率 > 70% でも Circuit Open

**B. pre_receive の timeout を少し抑える**

- デフォルト: 2 秒
- 最大: 3 秒（設定上限）
- AI 系で時間がかかる処理は **必ず post_receive / 非同期フローに載せる**ことを設計ガイドに明記。

→ こうすることで、SMTP セッションが延々と引きずられることを防ぎつつ、  
　pre_receive プラグインの影響範囲をかなり小さくできます。

---

### 1.2 read-only IMAP と権限システム

#### 懸念
- IMAP は Phase 2.5 まで read-only
- しかしプラグイン権限には `write_flags`, `move_message` 等が既にある
- プラグインがフラグ変更 → IMAP クライアントは反映を見るが、自分では変更できない → 混乱

#### 方針

- **Phase 1〜2.5 の間：**
  - `write_flags`, `move_message`, `delete_message` などの「ユーザー操作系」は、
    - **Web UI / API からは利用可能**
    - **IMAPは常にサーバーの状態を read-only 表示する**（＝プラグインの変更は見える）
  - ドキュメントで「IMAPは閲覧専用であり、状態変更はWeb UI/APIベース」と明記。

- **IMAP 書き込み対応時（Phase 3 以降）：**
  - IMAP の FLAGS / STORE / MOVE 等と内部権限モデルを同期
  - 「IMAPからの変更＝APIからの変更」として統一

※ ユーザー混乱を減らすため、IMAPクライアントからは
- フラグ変更操作を行っても「サーバー側で拒否」し、エラー応答を返す形にします  
（見た目だけ変わるよりは、明示的に弾いた方がマシ、という判断）。

---

### 1.3 送信スパム対策と pre_send Hook の順序

#### 設計選択

- 基本順序は **B) Policy Engine → プラグイン** を採用：

1. Outbound Policy Engine（レート／履歴ベース）でまずチェック  
   - 明らかなレート超過・異常パターンはここで即ブロック
2. 問題なさそうなら `pre_send` Hook でプラグイン呼び出し（AIスコアなど）
3. プラグイン結果も含めて最終判断（ブロック／警告／タグ付け）

- 例外的に「プラグイン結果を必ず見たい」ケース（DLPなど）は、
  - フック定義で `requires_before_policy = true` のようなフラグを設けて、
  - 特定プラグインのみ先行実行も可能にする（ただしデフォルトは後段）。

---

## 2. 実装詳細の不足箇所

### 2.1 認証・セッション管理

#### Admin UI 認証

- **Phase 1:**  
  - セッション Cookie ベース
  - サーバー側セッションストア（DB or in-memory + DB）
  - CSRF対策あり（SameSite=Lax/Strict）

- 将来的に:
  - OIDC / SAML による SSO を追加（Auth0 / Keycloak 等との連携）

#### API 認証

- **2パターンをサポート：**
  1. **API Key**（サービス間・スクリプト用）
     - 長期トークン、ローテーション可能
     - スコープ（read-only / admin / plugin 等）付き
  2. **Bearer トークン（JWT等）**
     - Admin UI ログイン時に発行する短命アクセストークン（内部利用）

- Phase 1 の最小構成:
  - API Key + セッションCookie（Admin UI）でスタート
  - OAuth2/OIDC は後フェーズ

#### SMTP AUTH

- Phase 1 サポート:
  - `PLAIN`, `LOGIN` (TLS/STARTTLS 上のみ)
- 将来オプション:
  - `CRAM-MD5`（レガシーだが、必要な環境向け）
  - `OAUTHBEARER`（Google WorkspaceやOIDC連携が必要になった時）

---

### 2.2 マルチテナント設計

#### 定義

- **Tenant（テナント）** = 組織単位（会社・チームなど）
- **Domain** = メールドメイン（`example.com` など）
- 1テナント: 複数ドメインを持てる
- 1ドメイン: 1テナントに所属（共有しない）

#### データ分離

- Phase 1: **論理分離**
  - 全てのテーブルに `tenant_id` を持たせる
  - クエリは必ず `tenant_id` でスコープ
- 物理分離（テナントごとにDBやインスタンスを分ける）は、
  - SaaS / エンタープライズ向けに将来検討

#### テナントごとのプラグイン設定

- プラグイン自体（バイナリ）は共有でも、
  - 「どのテナントで有効か」「設定値」はテナント単位
- つまり：
  - `global plugin registry` + `tenant plugin config` の二層構造。

---

### 2.3 キュー実装

#### Phase 1 デフォルト

- **PostgreSQL バックエンドの組み込みキュー**
  - シンプルな `jobs` テーブル（ステータス・リトライ回数・payload）
  - メール送信キュー、post_receive フック実行、非同期AI処理など

メリット:
- 追加ミドルウェア不要
- トランザクションと一緒に扱える

#### 将来の拡張

- NATS / Redis / RabbitMQ は「queue backend plugin」として設計
- 高スループットが必要な環境では外部キューに切り替え。

---

## 3. 運用シナリオ

### 3.1 障害復旧シナリオ（ざっくり方針）

#### DBクラッシュ

- 前提: 定期バックアップ（dump or snapshot）
- リカバリ手順:
  1. DB を復旧（最新スナップショット + WAL 再生）
  2. メール本体（FS/S3）は基本的に不変なので再アップロード不要
  3. `mairust` に `db-repair` / `consistency-check` 的なコマンドを用意し、孤児オブジェクトを検出・処理

#### S3 アクセス不可

- 受信時:
  - メッセージ保存に失敗 → tempfail（4xx）を返す
  - 長く続く場合は管理者にアラート
- 閲覧:
  - 該当オブジェクト取得に失敗した場合は UI/ログにエラー表示
  - DBは残るため、少なくとも「見えないが存在する」状態を明示

#### プラグインサーバー全停止

- Circuit Breaker + health check により「利用不可」と判定
- そのプラグインが必須かどうかで挙動を変える:
  - `required = false` → プラグインをスキップして本体処理続行
  - `required = true` → 関連処理を停止/拒否（例: DLP必須の環境など）

---

### 3.2 アップグレードシナリオ

#### Core のローリングアップデート

- DBスキーマ変更が「後方互換な追加」の範囲なら：
  - ノードごとに順次アップデート可能
- 破壊的変更の場合：
  - メジャーバージョンアップとして扱い、ダウンタイムを伴うメンテモードを前提

#### DBマイグレーション

- 標準の SQL マイグレーションツールを利用
  - 例：`mairust migrate` コマンドで versioned migration を実行
- マイグレーションは idempotent & ロールバックポリシー明記

#### API deprecation

- `/api/v1` で廃止予定エンドポイントには `Deprecation` ヘッダを付与
- ドキュメントに「予定廃止日」を明記
- 12〜24ヶ月の猶予期間を設ける方針は維持。

---

## 4. セキュリティ詳細

### 4.1 TLS

- 最小バージョン: **TLS 1.2**
- 推奨: TLS 1.3 対応、クライアントが対応していれば優先
- 弱い暗号スイート（RC4, 3DES等）は無効
- 管理者向けには「推奨設定サンプル」を documentation に掲載

### 4.2 秘密情報の保存

- パスワードは PBKDF2/Argon2 等でハッシュ
- APIキー・プラグインシークレット等は:
  - マスタキー（環境変数 or KMS）で envelope encryption
  - 例: AES-GCM or ChaCha20-Poly1305

### 4.3 監査ログ

- 監査対象:
  - ログイン/ログアウト
  - 設定変更（ドメイン/ユーザー/プラグイン/フック）
  - 管理者操作（アカウントロック/解除など）
- JSON構造の audit log を別ストリームで保存
- 保存期間（デフォルト）: 180日  
  → 設定で短縮/延長可能

### 4.4 脆弱性対応

- 公開窓口:
  - SECURITY.md に連絡先（メールアドレス）を明記
- 流れ:
  - 受領 → 調査 → パッチ → GitHub Security Advisory 発行
  - 必要に応じて CVE 取得（メンテナが CNA経由で申請）

---

### 4.5 プラグインセキュリティ追加

- 「外部への情報送信を検知して完全に防ぐ」ことは困難なので、
  - 原則として **機密情報を扱うプラグインのネットワークを `none` or `local-only` にすることを推奨**
- それでも outbound 必須のプラグインに対しては:
  - send先のドメイン/ホストを allowlist で明示
  - 送信先・送信回数をメトリクス & ログに集約し、
    - Admin UI で「どのプラグインがどこにどれだけ送信しているか」を可視化

---

## 5. 具体的な数値・閾値の扱い

基本方針:  
**すべて「デフォルト値」であり、設定で変えられることを明示**します。

- S3 multipart threshold = 8MB  
  → AWSのベストプラクティス（5〜8MB以上でマルチパート）に倣った値  
- body preview = 4KB  
  → 日本語メールでざっくり 1,000〜1,500文字程度。  
     必要なら `preview_bytes` 設定で 4〜16KB くらいまで調整可能にする。
- Hook timeout max = 3秒（pre_receive）  
  → 長い処理は post_receive に回す前提なので、短めで妥当と判断。
- Rate limit (user) 60 req/min  
  → 実装後に実運用からフィードバックを得て調整。  
     デフォルト値と「推奨計測手順」をドキュメント化。
- Circuit Breaker 80%  
  → こちらもデフォルトとして、運用で調整可能。  
     pre_receive 用にはより厳しい専用ルールを導入済み。
- 削除メッセージ保持 30日  
  → デフォルト値。  
     法的要件（e-Discovery等）がある環境では、  
     テナントごとに適切な値に変更することを推奨。

---

## 6. 用語統一（Glossary ラフ版）

- **Hook**:  
  MaiRust 内部の処理タイミング（pre_receive, post_receive, pre_send など）で呼ばれる内部イベントポイント。
- **Webhook**:  
  Hook から HTTP で外部サービスを呼び出す形の「通知／連携」のこと。
- **Plugin**:  
  MaiRust の拡張機能の総称（Hook Plugin / Service Plugin / Storage Plugin / UI Plugin）。
- **Worker**:  
  Plugin のうち、バックグラウンドで動くサービスやジョブ処理プロセスを指す用語。  
  → ドキュメント上は「Plugin Worker」に統一してもよい。
- **Tenant**:  
  組織単位（会社・チーム）。課金や権限管理の単位。
- **Domain**:  
  メールドメイン（example.com）。テナントに紐づく。
- **Organization**:  
  将来、SaaS 等で複数テナントを束ねる概念として使う可能性あり。Phase 1 ではほぼ使用しない。
- **Callback**:  
  Plugin → MaiRust に結果を返すための HTTP 呼び出し（内部API）。
- **Webhook**:  
  MaiRust → 外部サービスへの HTTP 通知。  
  → 方向が逆であることを用語で区別。

---

## 7. 次フェーズへの申し送り（ざっくり方針だけ）

- **JMAP**:  
  IMAP/POP 後に検討。  
  モダンなクライアント向けには相性が良いため、Phase 3〜4 の「オプションプロトコル」として想定。
- **CalDAV/CardDAV**:  
  「メールだけ」にフォーカスするため、Phase 1〜3 では対象外。  
  将来、外部グループウェア連携（Google/Microsoft等）で補完する方針。
- **E2E暗号化（PGP/S-MIME）**:  
  当面は「クライアント側で実施」モデルを前提。  
  サーバー側は「暗号化された本文をそのまま保管・配送」するだけ。  
  将来的にメタ情報の扱いや Key Management を検討。
- **Compliance (SOC2, ISO27001)**:  
  OSSとしての仕様レベルでは「ログ・監査・バックアップ・セキュリティ対応フロー」を整えておき、  
  実際の認証取得は商用SaaS提供時のタスクとする。

---

## 8. Phase 1 実装前に「決めきった」と言える項目

- Admin UI 認証:  
  → セッション Cookie + サーバー側セッション。  
- API 認証:  
  → API Key + 短命トークン（将来OAuth2/OIDC）。  
- キュー実装:  
  → Phase 1 は PostgreSQL ベースの組み込みキュー。  
- SMTP AUTH:  
  → PLAIN/LOGIN over TLS/STARTTLS（CRAM-MD5は後回し）。  
- TLS 最小バージョン:  
  → 1.2（1.3は可能なら有効）。  
- ログフォーマット:  
  → JSON構造化ログ（開発用にプレーンへ切替オプション）。  
- REST エラーコード体系:  
  → HTTPステータス + `code` / `message` / `details` フィールドを持つ共通エラーレスポンス。  
- SMTP エラーコード:  
  → tempfail: 4xx, permanent: 5xx、プラグインからコード指定可能。  
- 設定ファイル形式:  
  → YAML。スキーマは JSON Schema or 自前バリデータで厳密化。

---

## 9. ドキュメント整備 TODO（Phase 1 前）

- 用語集（Glossary）の正式版
- C4 Model によるアーキテクチャ図（System / Container / Component）
- データモデル（ER図）
- API エンドポイント一覧ドラフト（OpenAPIベース）
- 「開発者向けクイックスタート」と「運用者向けインストールガイド」

---
