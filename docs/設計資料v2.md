
# MaiRust 設計ノート v2  
追加検討結果 / デフォルト方針案（Apache-2.0 / PostgreSQL-First）

このドキュメントは、前回の設計ノートに対するフィードバックで挙がった
残課題・新規疑問点に対して、暫定の設計方針を示すものです。

---

## 1. アーキテクチャ関連

### 1.1 ストレージ設計詳細

#### 1.1.1 S3 マルチパートアップロード閾値

- デフォルト閾値: **8MB**
  - 8MB 未満: 通常 `PUT`
  - 8MB 以上: マルチパートアップロード
- 設定で変更可能:
  - `s3.multipart_threshold_mb` (例: 8〜128MB)
- 理由:
  - 小さすぎると S3 側のオーバーヘッドが無駄
  - 大きすぎると帯域の遅い環境でアップロード失敗時のリスクが増える

#### 1.1.2 Meilisearch vs Elasticsearch

**デフォルト: Meilisearch 推奨**

- Meilisearch:
  - 長所: セットアップが軽い、シンプルな API、単体コンテナで完結
  - 短所: 超大規模（数億通）を想定した場合はチューニング余地が限られる
- Elasticsearch/OpenSearch:
  - 長所: 大規模・高スケール・複雑クエリに強い
  - 短所: 運用が重い（クラスタ構築・ JVM チューニング等）

**選択基準:**

- 小〜中規模（数百万通レベル） → **Meilisearch**
- 大規模・既に ES/OS を運用している → **Elasticsearch/OpenSearch**

README には「検索エンジンなし / Meilisearch / Elasticsearch」の3構成を例示する。

#### 1.1.3 暗号化（S3）

**サーバサイド暗号化 (SSE-S3/SSE-KMS)**

- デフォルト: **SSE-S3** 利用（S3側の鍵管理に任せる）
- 企業が KMS を使いたい場合:
  - `encryption = "sse-kms"` + `kms_key_id` 設定

**クライアントサイド暗号化**

- Option として設計のみ用意:
  - `encryption = "client"` の場合、アップロード前に MaiRust 側で暗号化
- 留意点:
  - インデックスや検索との相性が悪くなるため、  
    「非常にセンシティブな環境向けの上級者オプション」として扱う

#### 1.1.4 メール削除ポリシー / ライフサイクル

- 「不変オブジェクト」とはいえ、**論理削除 vs 物理削除**を分ける

**論理削除:**

- DB上で `deleted_at` フラグ
- 通常の UI/API からは見えない
- しばらくはバックアップ・監査のために保持

**物理削除:**

- 定期クリーンアップジョブで、`deleted_at` から一定期間経過したオブジェクトを S3 から `DELETE`
- 期間設定例:
  - `retention.deleted_messages_days = 30`（デフォルト）
- S3 Lifecycle ルールと併用可能（アーカイブ→削除など）

---

### 1.2 Hook Manager / フック失敗時挙動

#### 1.2.1 tempfail 時の再試行ポリシー

- SMTP レベルの再試行は送信元 MTA に委ねられるため、
  - **MaiRust側で再試行キューを持つのは「内部処理のみ」**とする
- `post_receive` など非同期フックで失敗した場合:
  - 再試行回数: デフォルト 3 回
  - バックオフ: 30秒 → 2分 → 10分
  - 超過後: 「 permanent-failed 」としてログ・メトリクス保存

#### 1.2.2 Circuit Breaker

- プラグインごとに失敗カウンタを持つ:

```text
N 回連続失敗 → 一時的に自動無効化
````

* デフォルト:

  * 連続 10 回失敗 or 5 分間の失敗率 > 80% → Circuit Open
  * Circuit Open 中は該当プラグインをスキップ（ログ通知）
  * Admin UIで状態を確認・手動で再有効化可能
  * 自動半開 (Half-Open) モードも検討（一定時間後に1リクエストだけ試す）

---

### 1.3 API 設計

#### 1.3.1 Rate Limiting

* 粒度:

  * ユーザー別
  * IP別（特に管理系）
  * エンドポイント別（高コストAPI）

**デフォルト例（あくまで初期案）:**

* 一般ユーザー: 60 req/min
* Admin API: 30 req/min per IP + strict burst 制限
* プラグイン用内部API: 別枠（トークンごとに設定）

実装:

* Rust側では `tower` 系ミドルウェアでレート制御
* Redis 等をバックエンドにすれば分散構成でも可能

#### 1.3.2 Pagination 方式

* **cursor-based を推奨 / デフォルト**

  * `/messages?limit=50&cursor=xxxx`
* 技術的にシンプルな場合は offset も許容

  * `/logs?limit=100&offset=0`
* 大量データ（メッセージ一覧等）は cursor のみサポートとしてもよい

---

## 2. プラグインアーキテクチャ

### 2.1 実行環境

#### 2.1.1 Phase 1 の「OSユーザー分離」の実装イメージ

* プラグイン実行用ユーザー: `mairust-plugin` を作成
* `setuid` / `setgid` で:

  * Core: `mairust` ユーザー
  * プラグインプロセス: `mairust-plugin` ユーザー
* ファイルアクセス:

  * プラグイン用ワークディレクトリを `/var/lib/mairust/plugins/<id>` として分離
  * メール本体へのアクセスは、API/SDK 経由のみを原則とし、直接ファイルパスは渡さない

#### 2.1.2 `network = "outbound-limited"` の具体例

* `none`: ネットワークアクセス禁止
* `local-only`: `127.0.0.1` / `::1` のみ許可
* `outbound-limited`:

  * DNS解決は許可
  * 一部の well-known ポートのみ（443/80）許可
  * 宛先IP/ドメインを allowlist で制限可能
* `unlimited`: OS のネットワーク制限なし（非推奨 / 明示的許可が必要）

初期は「宣言的設定＋ベストエフォート」で、
将来的に iptables / eBPF / CNI 連携なども検討。

#### 2.1.3 プラグインのヘルスチェック

* Service Plugin には `health_endpoint` (HTTP) or `health_cmd` を定義可能
* Core から定期的にチェック:

  * 成功: OK
  * 連続失敗: Circuit Breaker発動・アラート
* `health/status` で以下返却:

  * `status`: ok / degraded / error
  * `details`: 任意文字列

#### 2.1.4 プラグインログ収集

* STDOUT/STDERR をキャプチャし、以下に出力:

  * ローカルファイル: `/var/log/mairust/plugins/<id>.log`
  * オプションで構造化ログ（JSON）として主ログに統合
* ログレベルは plugin.toml で指定可能
* Admin UI から「プラグインログ」を参照可能

---

### 2.2 権限システム

#### 2.2.1 添付ファイルアクセス権

新たに `read_attachments` 権限を追加:

* `none`: 添付ファイル情報一切渡さない
* `metadata`: ファイル名/サイズ/MIMEタイプのみ
* `preview`: 小さいファイル or 先頭数KBのみ（text系）
* `full`: オリジナルファイル全体へのアクセス許可

メール本体同様、プライバシー & パフォーマンスを考慮してデフォルトは `metadata` にとどめる。

#### 2.2.2 権限の組み合わせ制約

* 例:

  * `write_tags` → `read_headers` が暗黙的に必要
  * `move_message` → `read_headers + read_body (preview以上)` が必要
* 実装:

  * plugin.toml の解析時に依存関係をチェックし、足りない場合はエラー or 自動追加（UIに明示）

---

### 2.3 認証・セキュリティ詳細

#### 2.3.1 X-MaiRust-Signature 対象ヘッダ

署名対象:

* リクエストボディ（必須）
* 以下のヘッダを結合:

  * `X-MaiRust-Timestamp`
  * `Content-Type`
  * `X-MaiRust-Plugin-Id`

フォーマット例:

```
string_to_sign = timestamp + "\n" + plugin_id + "\n" + sha256(body)
signature = HMAC-SHA256(secret, string_to_sign)
```

#### 2.3.2 リプレイ攻撃対策

* `X-MaiRust-Timestamp` を UTC 秒で付与
* プラグイン側/コア側とも「±5分」の範囲でのみ受理
* nonce までは Phase 1 では見送り（必要なら将来導入）

---

## 3. マーケットプレイス

### 3.1 審査 & 公開停止

#### 3.1.1 静的解析で何を見るか

* メタデータ:

  * 必要以上の権限要求（full body + move + write_metadata など）
* 依存関係:

  * 既知の脆弱ライブラリバージョン
* パッケージ構成:

  * 不審なバイナリ・シェルスクリプト等
* 可能であれば:

  * OSSならソースとの対応確認（将来的検討）

#### 3.1.2 悪意プラグイン発覚時のリコール

* Marketplace 側:

  * 該当プラグインIDを「ブロックリスト」登録
  * インストール済みインスタンスに「セキュリティアラート」通知（API/メール）
* MaiRust インスタンス側:

  * 次回 Marketplace との同期時にアラート表示
  * 管理UIに「このプラグインは危険と判定されました。無効化/削除してください」表示
  * 将来的には「自動無効化」オプションも提供

#### 3.1.3 バージョン互換性の UX

* 旧MaiRustで新プラグインをインストールしようとした場合:

  * 明確なエラーメッセージ:

    * 「このプラグインは MaiRust 0.4.0 以降でのみ動作します（現在: 0.3.2）」
  * アップグレードガイドへのリンク

---

### 3.2 技術的詳細

#### 3.2.1 署名アルゴリズム

* Marketplace署名: **Ed25519**

  * 高速・鍵管理がシンプル
* 開発者署名（オプション）: Ed25519 or RSA-2048 を許可

#### 3.2.2 プラグインパッケージ形式

* 拡張子: `.mairust-plugin`
* 実体: `tar.gz` 形式（中身に `plugin.toml`, `README.md`, `icon.png`, バイナリ等）
* 署名:

  * `manifest.json` にダイジェスト一覧
  * `.sig` ファイルに署名を格納

---

## 4. 送信スパム対策

### 4.1 Outbound Policy Engine 詳細

#### 4.1.1 スコアリング

一例（簡易モデル）:

* 基本式:
  `score = w1 * rate_factor + w2 * content_factor + w3 * history_factor`

デフォルト重み:

* `rate_factor`: 0.4
* `content_factor`: 0.4
* `history_factor`: 0.2

しきい値:

* `score < 0.5`: 許可
* `0.5 <= score < 0.8`: 警告/軽い制限
* `0.8 <= score`: 強制停止候補

※ 初期は「しきい値ベース」で実装し、weight と threshold は設定可能とする。

#### 4.1.2 学習データ保存期間

* 最低限必要な期間: 過去 ~30日（最近の送信傾向を掴むため）
* デフォルト:

  * 詳細ログ: 30日
  * 集計済み統計: 180日
* GDPR 等を考慮して、保持期間は設定で短くもできるようにする。

#### 4.1.3 正当な大量送信（ホワイトリスト）

* 「大量送信プロファイル」を定義できるようにする:

```yaml
outbound_whitelist:
  - id: "newsletter"
    accounts: ["news@company.com"]
    max_rate: "5000 msgs/hour"
    description: "Official newsletter"
```

* Whitelist に載っているアカウントは、通常とは別のしきい値/ルールで評価

---

### 4.2 監視サーバー連携

#### 4.2.1 monitor.mairust.io の運用主体

* OSSの設計ドキュメントでは:

  * `monitor.mairust.io` は「**将来想定される SaaS サービスの例**」として書く
  * 実際の運用主体は、MaiRust 提供企業 or コミュニティによって決定
* 完全OSS版では:

  * デフォルトでは **無効**
  * 有効化するには管理者が明示的に設定する

#### 4.2.2 通知の頻度制限

* 同一アカウントについて:

  * 最低間隔: 10分
  * 1日あたり最大: 24回 など
* 全体について:

  * システム全体の通知レートも制限（例: 1秒に1回を上限）

#### 4.2.3 通知失敗時の挙動

* 原則:

  * 監視サーバーへの通知失敗は **送信ブロックの理由にはしない**
  * 送信系の可用性を優先
* ただし以下はログ・メトリクスで可視化:

  * 通知失敗の回数
  * 監視サーバーのダウン検知

---

### 4.3 送信停止の解除

#### 4.3.1 ハードリミット解除手順

* デフォルト:

  * 管理者が Admin UI/CLI から手動解除
* オプション:

  * `auto_reenable_after_hours`（例: デフォルト 0=自動解除なし）
  * 例えば 24h 経過後に自動で SoftLimit 状態に戻す設定も可能

#### 4.3.2 ユーザーへの通知方法

* メール送信 API/SMTP のレスポンスで明示的なエラー文言:

  * `550 Sending from this account is temporarily suspended. Please contact your administrator.`
* Web UI ではバナー表示:

  * 「あなたのアカウントは送信一時停止中です」
* 将来的には:

  * 管理者宛への自動メール通知（別アドレス）
  * Webhook 連携（社内チャット通知など）

---

## 5. コンテナ配布

### 5.1 オールインワン構成

#### 5.1.1 組み込みPostgreSQLの永続化

* 推奨ボリューム:

  * `/var/lib/mairust/db` (PostgreSQL データ)
  * `/var/lib/mairust/mail` (メールファイル)
* docker-compose 例で明示する:

```yaml
volumes:
  mairust_db:
  mairust_mail:

services:
  mairust:
    image: mairust/all-in-one:latest
    volumes:
      - mairust_db:/var/lib/mairust/db
      - mairust_mail:/var/lib/mairust/mail
```

#### 5.1.2 イメージサイズ目標 & マルチアーキ

* 目標サイズ:

  * < 500MB （AIO構成としては妥当なライン）
* マルチアーキ:

  * `linux/amd64` + `linux/arm64` を公式ビルドターゲットとする

### 5.2 本番構成への移行

#### 5.2.1 マイグレーションツール

* `mairust migrate-db --from=embedded --to=postgres://...`
  のような CLI を用意
* 実体は:

  * pg_dump / pg_restore 的な動き
  * データ整合性を確保した停止 or read-only モードでの実行を推奨

#### 5.2.2 Helm / Compose

* 公式として以下を提供:

  * `docker-compose.yml`（開発/小規模用）
  * Helm Chart（本番クラスタ用）
* Kubernetes Operator は Phase 4 以降のタスクとして維持

---

## 6. ロードマップ関連

### 6.1 Phase 1 AI エンジン

* **優先エンジン: rspamd 連携 + シンプルな独自ルール**

  * rspamd と連携すれば既存の豊富なルールを活用可能
  * 独自AI/LLM ベースのスパム判定は Phase 2 以降の追加価値として

### 6.2 read-only IMAP の範囲

* 機能範囲:

  * メール一覧取得
  * メッセージ取得
  * フォルダ一覧
* できないこと:

  * フラグ変更（既読/未読など）
  * 移動/削除
* 初期は「閲覧専用IMAP」として提供し、
  書き込みは Web UI/API のみに限定することで整合性を保つ。

### 6.3 Phase 1 MVP の完了定義（例）

* SMTP受信
* ローカルストレージ + PostgreSQL
* REST API（ユーザー・ドメイン・メール一覧/閲覧）
* シンプルWeb UI（ログイン + メール一覧/閲覧）
* 受信スパム検出（rspamd連携 or シンプルルール）
* Hooks:

  * `post_receive` のみ実装（最小セット）
* 基本的な監視（Prometheusメトリクス）

### 6.4 OSS コミュニティ戦略（簡易案）

* 最初から GitHub 上で公開
* `good first issue` `help wanted` ラベル整備
* サンプルプラグインリポジトリを用意
* Discord / Slack / Matrix など、コミュニティチャットを 1つ用意
* 日本語/英語の README を最初から用意

---

## 7. 全体の運用・テスト・ドキュメント

### 7.1 ログ

* 形式: **JSON 構造化ログ** をデフォルト

  * 開発中には人間向けプレーンテキストに切替可能なオプション
* JSONの主なフィールド:

  * `timestamp`, `level`, `component`, `message`, `request_id`, `plugin_id` など

### 7.2 設定ファイル

* メインフォーマット: **YAML**

  * 人間に読み書きしやすい
* 将来的に TOML も検討可だが、初期は YAML のみに絞る

**ホットリロード:**

* `mairust reload` コマンド or SIGHUP
* 一部の設定のみホット適用:

  * Hooks/Plugins/RateLimit/Logging レベル etc.
* ポート変更や DB 設定など、プロセス再起動が必要な項目は明示

### 7.3 Graceful Shutdown

* 新規接続受付停止
* 既存SMTPセッションが一定時間内（デフォルト 30秒〜60秒）に完了するのを待つ
* キュー処理中のジョブは終了まで or タイムアウトまで待機
* フック呼び出し中のものは、短いグレース期間後にキャンセル

### 7.4 テスト戦略

* E2E:

  * docker-compose で mini環境を起動し、SMTP/REST/Web UI を一通りテスト
* 負荷テスト:

  * 目標（例）:

    * 1ノードあたり 100〜500 msg/sec 程度を目安
  * k6 / locust 等で API 負荷も計測
* セキュリティ:

  * CIで静的解析（Rust, JS）
  * 公開前/メジャーリリース前にペネトレーションテスト（外部 or コミュニティ）

### 7.5 ドキュメント

* ホスティング:

  * GitHub Pages or `docs.mairust.org`（mkdocs / Docusaurus）
* APIリファレンス:

  * OpenAPI を Rust コードから自動生成＆公開
* プラグイン開発ガイド:

  * 別リポジトリ `mairust-plugin-examples` を用意
  * HTTPプラグイン / STDINプラグイン / AIプラグイン / Storageプラグイン のサンプルを収録

---

## 8. 優先度まとめ（改めて）

* 優先度高:
  * 送信スパム対策（Outbount Policy Engine の初期実装）
  * プラグイン署名・鍵管理の最低限実装
  * Phase 1 MVP の定義に沿った Core/API/UI/Hook の実装
  
* 優先度中:
  * コンテナイメージ構成・サイズ最適化
  * Meilisearch インテグレーション
  
* 優先度低:
  * UI Plugin の詳細仕様
  * 高度な Marketplace/課金機能

